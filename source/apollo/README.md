# Cyber
Cyber是百度Apollo自动驾驶推出的替代ROS的消息中间件。Cyber RT的核心功能是计算任务调度和提供底层通信服务。

![20210413191133](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413191133.png)

## 从ROS中来
Apollo`1.0-3.0`一直使用ROS作为底层的通信框架，ROS是主要运用与机器人领域的一种开源框架时一种**分布式的松耦合设计**，后来被开发者运用到了自动驾驶领域(日本-`Autoware`)。从软件架构角度上来说，它是一种基于Socket消息传递通信的分布式多进程框架，开发者可以根据自己的情况，将需求拆分成各个模块，每个模块只负责接受消息、并根据消息进行处理计算、发布新的消息，模块之间通过(`Topic、Service、Action`)消息进行关联，将各个模块串联起来实现最终功能。

1. 使用ROS的一些好处
   * 拥有许多好用的工具: rviz、rqt、gazebo、rosbag等等
   * 使用时不必考虑底层实现原理，开发者可以快速部署和验证技术方案和算法功能。
   * 应为其是目前最广泛的开源机器人操作系统，拥有众多优秀的算法包。
  
2. ROS存在的一些不足
   * 效率低：因为其底层使用socket通信，导致各个节点之间的通信效率低。
   * 可靠性差：所有消息都通过一个Master节点进行集中式消息管理，如果Master节点应为异常原因挂掉则会影响整个系统。
   * 消息格式不够灵活：新改动过的msg消息不能向下兼容旧版的msg消息。
   * 实时性差：在ROS中，计算任务都会执行在一个一个线程中，当系统中存在大量计算任务的时候，会衍生出大量的线程，对调度系统而言是一个非常大的负担，会引入很多的线程切换，导致系统的实时性难以保障。

为了结果ROS天生存在的一些问题，Apollo开发出了自己的一套底层通信框架CyberRT。

## Cyber基本概念
![20210413194310](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413194310.png)
CyberRT从下到上基本分为：`基础库层`、`通信层`、`数据缓存和融合层`、`计算调度层`以及为算法模块提供的`抽象接口`：
   * Publish-SubscribeSystem：通信层使用经典的Pub/Sub的匿名通信模式, 基于动态的服务发现去除了中心化的节点，同时也支持进程间和跨机通信。
   * DataCache/FusionFramework：由于很多算法需要多路数据进行计算，因此框架提供了基础的多路数据融合功能。此外，框架还提供了数据的Observe模式，方便算法能够根据业务定义数据融合策略，也为离线仿真等业务提供更好的控制力度。
   * ParallelComputingModel：屏蔽了操作系统的底层细节，不再对应用层体现线程的概念，而是将其封装为Processor，并结合[协程](https://zhuanlan.zhihu.com/p/172471249)的使用，实现了用户空间的任务调度和切换。
   * TaskAbstractInterface：为算法开发者提供的实现任务的统一接口，接口是面向对象的高度封装类，在Cyber RT中叫做Component, 使用者只需要按需求选择相应的Component，然后实现其中的初始化、任务处理等接口，即可加载到框架中运行，而无需关注底层的具体执行单元和线程模型。

Cyber RT中有几个基础的概念十分重要，分别是`Mainboard`，`Component`，`Channel`和`Task`:
   * **Mainboard**：是Cyber RT的主进程，主要功能是解析dag配置文件，通过动态加载的方式读取算法模块，并完成整个系统的初始化，相当于整个系统运行的载体。

   * **Component**：是Cyber RT的最基本模块，每个算法都可以封装为一个独立的Component，定义算法的输入数据及处理函数。Component是系统中可插拔的最小单元，通过Mainboard加载并执行。

   * **Channel**：是Cyber RT中数据通信的总线，通过Channel名称来区分不同的消息通路，模块间通过Channel来匹配并建立连接，实现通信。

   * **Task**：是Cyber RT框架中的基本计算单元，是调度器用来执行的最小单元，对用户来说Task类似一个与特定数据绑定的函数指针，用来处理一类特定任务。

## CyberRT运行流程
![20210413200542](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413200542.png)
1. 自动驾驶系统一般是由Sensor驱动的，需要采集每个Sensor的数据，多路传感器数据会作为系统的输入源驱动整个系统运转。
2. 框架根据每个`Component`的输入输出关系，将各个Component串联起来，形成一个DAG计算图。
3. `Task Scheduler`把每个`Component`里面的具体算法及输入的Channel进行绑定，生成一个个独立的可执行单元，再根据具体的调度策略将Task发送至执行池。
4. 底层具体的执行库，多个Worker根据预设的策略并行执行分配给自己的Task。

## CyberRT任务调度
为了满足实时性能需求，Cyber RT做了一个专用的调度系统。它将调度的逻辑从内核空间抽离到用户空间，使用协程作为基础的调度单元。传统的多线程模型中用户的计算对应于一个个线程，而线程则对应于CPU的核心，线程的调度和切换则依赖Kernel的调度算法，可控性较低；在用户空间的调度中，用户的任务会对应于一个个协程，协程则对应于Processor，Processor对于Task的执行和切换完全在用户空间，由具体的调度器来控制。   

![20210413201739](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413201739.png)

对于每个车上的计算任务，无论是单个传感器数据的预处理还是车辆的底层控制算法，Cyber RT都抽象为一个个独立的Task，每个Task创建时对应一个协程，每个协程有一套独立的上下文信息，包含栈及寄存器信息。   

Task创建完成后统一交由调度器，分配至对应的Processor上，每个Processor对应操作系统的一个真实的线程。   


通常情况下，Processor与CPU的逻辑核是一一对应的，避免任务在运行过程中在不同的CPU间频繁迁移，造成过多的上下文切换和Cache Miss。   


目前Cyber RT主要提供了**编排模式**和**经典模**式两种调度策略，与传统的服务端应用相比，自动驾驶任务有一个特点，大部分任务都是以一定周期运行的。调度器可以预先知道每个时刻应该执行哪些任务，以及任务之间的优先级关系。**编排策略**正是基于这一特性，通过对系统具体业务的分析，预先配置好每个任务在哪个CPU上运行以及任务之间的先后关系，例如将相互之间无依赖的任务放到不同CPU上提高并行度，将存在上下游关系的任务放在同一个CPU上运行，这样任务的分配和调度主要集中在初始化阶段，一旦任务编排完成，只需要按照顺序进行执行即可，减少运行期的动态调整。

底层的Processor划分以及每个Task应该分配到哪个Processor上是由调度策略来决定的。   
![20210413202006](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413202006.png)

如图中左边部分所示，在编排策略下，各个任务都是绑定在固定的Processor上，并与CPU逻辑核绑定，在运行期能大幅减少线程切换及Cache Miss的开销，减少系统的不确定性。


系统中在极端情况下可能出现一些高优任务被阻塞。为了解决这种情况，Cyber RT保留了一些预留的Processor，如右边虚线部分所示，当有临时的高优先级任务出现时，会调度到这个高优先级的Processor上，由于这些Processor底层是实时线程，所以可以实现用户空间的任务抢占，保证实时任务的执行。


其次是经典策略。与编排相比，经典策略的逻辑更像是传统的线程池的模式，每个Processor不在有单独的任务队列，task也不会固定在某个Processor上，所有的Processor共用任务队列，并以先进先出的方式执行任务。


在这种策略下，为了能够支持任务的优先级区分，Cyber RT实现了多优先级队列机制，每个任务根据优先级进入不同的队列，在保证高优任务优先执行的情况下，也能够尽量减少单队列带来的并发瓶颈。

此外，我们也支持线程池进行了分组管理，可以将Processor分为多组，不同线程池之间的Task无法迁移，实现资源隔离，对于多Numa的CPU架构有比较好的支持。


## CyberRT通信
自动驾驶系统需要多种传感器协同工作，以覆盖不同场景、不同路况的需求。多种传感器共同使用的一大问题是传输带宽需求比较大，其中相机和激光雷达数据量非常大，分别达到了180MB/S和70MB/S，而主流的多传感器融合方案至少会包含一个激光雷达和多个相机。当车辆在高速行驶过程中，一旦出现通信的延迟或者数据的丢帧，对行车安全会造成极大的威胁。


在Cyber RT中，为了兼顾集中式部署时的高性能以及分布式部署的灵活性，我们提供了自适应的通信方式，尽量以最高效的方式来进行数据传输。这些通信方式对开发者来说是透明的。开发者只需要指定发送的Channel名称及类型即可， Cyber RT框架会根据模块之间的关系**动态选择适合的通信方式**。例如，当两个模块处于同一个进程中的时候，会直接进行**指针传递**，减少了序列化及内存拷贝的开销。当两个模块处于同一台机器的不同进程中的时候，会使用**共享内存**的方式来进行通信，避免数据的多次拷贝。当两个模块处于同一网络内的不同机器中时，则会使用**Socket**的方式来进行网络通信。通过自适应的通信方式，能够将模块开发与实际部署方案解耦，保证性能的同时也提供了比较好的灵活性。

![20210413203052](https://cdn.jsdelivr.net/gh/AzureCodeing/PicGoBed@main/blogs/pictures/20210413203052.png)

最下面一层是PDP层，用于进程之间的互相发现。对于每一个独立的进程，会有一个唯一的Participant，在进程初始化时通过组播的方式向域内的其他进程广播信息，用于彼此发现并建立点对点的连接。当连接建立后，通过心跳机制定期检查对方节点的存活状态，用以进行响应的异常处理。这一层描述的是不同进程之间的连接关系，并不涉及上层的业务应用。


在PDP之上，是EDP层，在两个节点通过PDP层完成点到点的连接建立之后，会通过单播的方式将本节点内的Channel、Service等信息发送给对方，框架中的各种通信、服务的Meta信息都在这一层进行传递，并交由Topology Manager来统一处理。


当服务的Meta信息传递给Topology Manager后，会进行消息发布者、订阅者的匹配，当两个节点之间的消息匹配成功后，自适应选择最高效的通信方式，并在Pub/Sub这一层建立连接完成最终的通信过程。


Cyber RT通过以上三层，实现发现、Meta信息交换、建立连接实现通信的功能。


在Cyber RT中基于Type Traits实现了自定义消息的支持，当两个Component加载到同一个进程中时，可以使用自定义的数据结构，直接以指针的方式传递，不需要额外的转换和拷贝。


需要注意的是，由于自定义消息没有对应的序列化和反序列化方法，无法跨进程传输，也无法通过Recorder工具录制，仅供模块在进程内部使用。

## Reference
1. [沙龙回顾 | Apollo Cyber RT计算框架详解](https://mp.weixin.qq.com/s/d4sLuJFiyFyL6NRhyx-i8A)